









OK.... PARA CRIAR 1 SERVICE PARA NOSSO APP,




PODEMOS USAR __ A COMMAND-LINE..

















--> OK... O PROFESSOR CRIA 1 NOVO TERMINAL...










--> ELE RODA 'kubectl'

PARA 


CRIAR 1 

SERVICE...











--> ELE DIZ QUE PODERÍAMOS CRIAR 1 'service' 


COM 

O COMANDO DE 'kubectl create service',
TIPO ASSIM:









Basic Commands (Beginner):
  create          Create a resource from a file or from stdin
  expose          Take a replication controller, service, deployment or pod and expose it as a new
Kubernetes service
  run             Run a particular image on the cluster
  set             Set specific features on objects

Basic Commands (Intermediate):
  explain         Get documentation for a resource
  get             Display one or many resources
  edit            Edit a resource on the server
  delete          Delete resources by file names, stdin, resources and names, or by resources and
label selector

Deploy Commands:
  rollout         Manage the rollout of a resource
  scale           Set a new size for a deployment, replica set, or replication controller
  autoscale       Auto-scale a deployment, replica set, stateful set, or replication controller

Cluster Management Commands:
  certificate     Modify certificate resources.
  cluster-info    Display cluster information
  top             Display resource (CPU/memory) usage
  cordon          Mark node as unschedulable
  uncordon        Mark node as schedulable
  drain           Drain node in preparation for maintenance
  taint           Update the taints on one or more nodes

Troubleshooting and Debugging Commands:
  describe        Show details of a specific resource or group of resources
  logs            Print the logs for a container in a pod
  attach          Attach to a running container
  exec            Execute a command in a container
  port-forward    Forward one or more local ports to a pod
  proxy           Run a proxy to the Kubernetes API server
  cp              Copy files and directories to and from containers
  auth            Inspect authorization
  debug           Create debugging sessions for troubleshooting workloads and nodes
  events          List events

Advanced Commands:
  diff            Diff the live version against a would-be applied version
  apply           Apply a configuration to a resource by file name or stdin
  patch           Update fields of a resource
  replace         Replace a resource by file name or stdin
  wait            Experimental: Wait for a specific condition on one or many resources
  kustomize       Build a kustomization target from a directory or URL

Settings Commands:
  label           Update the labels on a resource
  annotate        Update the annotations on a resource
  completion      Output shell completion code for the specified shell (bash, zsh, fish, or
powershell)

Other Commands:
  api-resources   Print the supported API resources on the server
  api-versions    Print the supported API versions on the server, in the form of "group/version"
  config          Modify kubeconfig files
  plugin          Provides utilities for interacting with plugins
  version         Print the client and server version information



















  CERTO...









  MAS AINDA QUE ISSO FUNCIONASSE

  SE O RODÁSSEMOS, 









  NÃO É ISSO O QUE ACTUALLY FAREMOS, AQUI...









  EM VEZ DISSO, 
  TEMOS 

  1 COMANDO 

  AINDA MAIS CONVENIENTE 

  PARA __ EXPOR__ OS PODS _ CRIADOS POR 1 DEPLOYMENT __ AO MUNDO EXTERIOR__ ----->








É O COMMAND DE  'kubectl expose'












--> esse comando faz o que diz o nome,

ele 

EXPÕE 1 POD, CRIADO POR 1 DEPLOYMENT,




POR MEIO DO CREATE DE 1 SERVICE....












--> BASTA ESCREVER 






kubectl expose deployment first-app --port 















--> COLOCAMOS 'deployment + o nome do deployment'..















-> também precisamos de 2 options essenciais, depois do nome 


desse deployment.... 









A PRIMEIRA OPTION É '--port',



que utilizaremos para especificar a PORT EM QUE QUEREMOS DEIXAR ESSE 




DEPLOYMENT 'exposed'...












--> É POR ISSO QUE O PROFESSOR ESCREVE 

'--port=8080'... 











--> ok.... além de '--port',



precisamos também adicionar a option 



'--type',







QUE É O 'TIPO DE SERVICE OU __ _EXPOSING'


QUE 

VC QUER CRIAR, AQUI...







E HÁ DIFERENTES TIPOS DE TYPES QUE VC PODE ESCOLHER...









HÁ DIFERENTES BUILT-IN TYPES...















--> 1 TYPE POSSÍVEL QUE VC PODE ESPECIFICAR É 'ClusterIP'...






'ClusterIP' é, na verdade,




o DEFAULT TYPE,

o que quer dizer que 

  







''''ESSE DEPLOYMENT SERÁ REACHABLE __ APENAS__ DE  DENTRO __ DO SEU CLUSTER'''...



















-> AINDA ASSIM,



A UTILIDADE DE 'ClusterIP' é que ele te dá um 'UNCHANGABLE ADDRESS',


que não vai mudar, e que pode ser usado no contexto interno do kubernetes cluster... 




















--> OK... ALÉM DE 'ClusterIP',






temos 





'NodePort',



QUE 



ACTUALLY SIGNIFICA 







''''ESSE DEPLOYMENT DEVERÁ SER ___ EXPOSTO COM A AJUDA DO IP ADDRESS 

DO __ WORKER__ NODE __ __ EM QUE ELE ESTÁ SENDO RODANDO''''' 











MAS MELHOR DO QUE ISSO,
 

 TEMOS 

 O 

 TYPE DE 'LOAD BALANCER' ('LoadBalancer') --> ESSE TYPE USA UM 'LOAD BALANCER',




QUE __ DEVERÁ EXISTIR (Vc precisa settar) NA SUA INFRAESTRUTURA,

NA INFRAESTRUTURA em que nosso cluster roda...




SE ESCOLHEMOS 'LoadBalancer' como type,  é esse load balancer que vai gerar 

1 

'unique address' para esse service... mas mais do que isso,

ele vai 

também 

'DISTRIBUTE INCOMING TRAFFIC EVENLY ACROSS ALL PODS WHICH ARE PART OF THIS 
SERVICE'...










-> TEMOS APENAS 1 POD NO MOMENTO,


MAS SE FÔSSEMOS ESCALAR NOSSO APP,




ISSO IMPORTARIA UM MONTE...











--> COMO TEMOS APENAS 1 POD,

NÃO TEMOS MÚLTIPLAS INSTANCES DESSE POD,




TER  O TYPE DE 'LOADBALANCER' AQUI NÃO FAZ TANTA DIFERENÇA... MAS EM PRODUCTION,


COM MÚLTIPLAS INSTANCES DESSE POD,




ISSO IMPORTARIA....















--> CERTO.... MAS O LOAD BALANCER,



ESSE TYPE DE 'LoadBalancer',



SÓ PODE SER USADO  __ SE 


O SEU CLUSTER E A INFRAESTRUTURA EM QUE O CLUSTER RODA 


SUPORTAM ESSA TECNOLOGIA...












--> O AWS SUPORTA ESSA TECNOLOGIA,

E O MINIKUBE TAMBÉM... POR ISSO PODEMOS USÁ-LA...










--> OK.... É POR ISSO QUE RODAREMOS ESTE COMANDO:



kubectl expose deployment first-app --type/LoadBalancer --port=8080









SE RODAMOS ISSO,



ENXERGAMOS 



'service/first-app exposed' 










--> ISSO MOSTRA QUE O SERVICE PARA _ ESSE DEPLOYMENT FOI CRIADO/SETTADO...

















-> podemos checar se ele foi criado,



com 'kubectl get services'...














VEREMOS ISTO:







C:\WINDOWS\system32>kubectl get deployments
NAME                  READY   UP-TO-DATE   AVAILABLE   AGE
my-first-deployment   1/1     1            1           5h4m

C:\WINDOWS\system32>kubectl expose deployment --type=LoadBalancer --port=8080
error: resource(s) were provided, but no name was specified

C:\WINDOWS\system32>kubectl expose deployment my-first-deployment --type=LoadBalancer --port=8080
service/my-first-deployment exposed

C:\WINDOWS\system32>kubectl get services
NAME                  TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
kubernetes            ClusterIP      10.96.0.1       <none>        443/TCP          5h48m
my-first-deployment   LoadBalancer   10.101.118.96   <pending>     8080:30107/TCP   9s

C:\WINDOWS\system32>


















CERTO...





AQUI, VEREMOS 2 SERVICS...














O de baixo,



'kubernetes',





TEM O TYPE DE 'CLUSTERIP',



E É 


1 SERVICE QUE É CRIADO AUTOMATICAMENTE, PELO PRÓPRIO KUBERNETES...



















-> CERTO...








MAS EM 'my-first-deployment' 





ENXERGAMOOS O SERVICE PARA O _ PRIMEIRO DEPLOYMENT... --> TEMOS O TYPE DE 

'LOADBALANCER',



e 



o 'CLUSTERIP',

que não nos ajudará...













--> CERTO...





TEMOS TAMBÉM O 'EXTERNAL IP' ---------> SE ISSO FOSSE DEPLOYADO EM 1 'CLOUD PROVIDER',


VERÍAMOS 1 VALOR ALI NO 'EXTERNAL-IP'... MAS COMO 


ESTAMOS NO MINIKUBE,


ESSE NEGÓCIO SEMPRE FICARÁ COMO 'PENDING'...













OK... MAS O MINIKUBE AINDA 'GOT US COVERED'...













A RAZÃO PARA AQUILO ALI ESTAR COMO '<pending>'



É JUSTAMENTE 




PQ O MINIKUBE AINDA É UMA 'VIRTUAL MACHINE'  RODANDO NA NOSSA LOCAL MACHINE... ELE NÃO TEM 


IPS DISPONÍVEIS PQ  '''''esses ips levariam a SITES OUT THERE''' ( e ele não tem permissão para isso)...
















----->portanto, não temos 1 external ip... --> mas O MINIKUBE TEM 1 COMANDO QUE 


NOS DÁ ACESSO A ESSE SERVICE DE 'my-first-deployment',





POR MEIO DO 'MAP DE 1 SPECIAL PORT A 1 IP',

IP 
QUE PODEMOS ACESSAR DE NOSSA LOCAL MACHINE,



E QUE ENTÃO IDENTIFICA ESSA VIRTUAL MACHINE, RODANDO NA NOSSA LOCAL MACHINE...












--> É O COMANDO DE 'minikube service my-first-deployment'...









minikube service .....










--> aí especificamos nosso DEPLOYMENT...







--> claro, se vc CRIOU SEU SERVICE EM 1 CLOUD PROVIDER,

CLOUD PROVIDER QUE SUPORTA 1 LOAD BALANCER,



VOCÊ VAI ENCONTRAR ALGUM 'EXTERNAL IP',

E AÍ 



ESSE COMANDO DE 'minikube service' 













-> ok... rodamos 'minikube service my-first-deployment'...















--> ESSE COMANDO VAI NOS DAR 1 TABLE COM 1 ADDRESS, QUE ENTÃO PODEREMOS USAR PARA 'VIEW'

A NOSSA APPLICATION...





EX:






C:\WINDOWS\system32>kubectl get services
NAME                  TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
kubernetes            ClusterIP      10.96.0.1       <none>        443/TCP          5h48m
my-first-deployment   LoadBalancer   10.101.118.96   <pending>     8080:30107/TCP   9s

C:\WINDOWS\system32>minikube service my-first-deployment
|-----------|---------------------|-------------|----------------------------|
| NAMESPACE |        NAME         | TARGET PORT |            URL             |
|-----------|---------------------|-------------|----------------------------|
| default   | my-first-deployment |        8080 | http://172.22.142.92:30107 |
|-----------|---------------------|-------------|----------------------------|
* Opening service default/my-first-deployment in default browser...















OK... ABRI ESSE ENDEREÇO...









-> VI MEU APP --> MEU NODE APP,

RODANDO NESSE CONTAINER,


QUE ESTÁ RODANDO NESSE POD,

QUE FOI CRIADO PELO KUBERNETES COM BASE __ NAQUELE 'DEPLOYMENT' QUE CRIAMOS 


E
 
ENVIAMOS AO 'KUBERNETES CLUSTER'...












--> E, POR CONTA DO 'KUBERNETES SERVICE', QUE CRIAMOS,


PODEMOS 

VISUALIZAR ESSE NOSSO APP __ LÁ NESSE ADDRESS 

DE 


'http://172.22.142.92:30107' 







ESSAS FORAM AS PRIMEIRAS ETAPAS CRUCIAIS...














--> DEPOIS VAMOS NOS AFASTAR DESSE APPROACH IMPERATIVE,

QUE ESTAMOS USANDO AGORA... AINDA ASSIM,




ESSAS SÃO GRANDES PRIMEIROS PASSOS...











OK...




COM O 'POD',

'DEPLOYMENT'


E 

'SERVICE' OBJECT TYPES,




APRENDEMOS SOBRE ALGUNS DOS MAIS IMPORTANTES TYPES DO KUBERNETES,

QUE 
UTILIZREMOS TODO O TEMPO COM ELE...












OK, MAS O QUE MAIS PODEMOS FAZER, COM O KUBERNETES?