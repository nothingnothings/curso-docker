## NADA IMPEDE QUE TENHAMOS MÚLTIPLOS RESOURCES (deployments, services, etc) EM 1 MESMO ARQUIVO... (mas é meio bagunçado)...
## OBS::: SE COMBINARMOS 1 'SERVICE' E 1 'DEPLOYMENT' EM 1 MESMO ARQUIVO, É UMA GOOD PRACTICE COLOCAR O SERVICE _ ANTES__ DO DEPLOYMENT...
## pq OS SERVICES SÃO CRIADOS, NOS ARQUIVOS '.yaml', DE CIMA PARA BAIXO (queremos que o service seja criado antes, para que já adicione os pods necessários, ao seu contexto)...



apiVersion: v1 # diferente de 'apps/v1', usada no 'deployment.yaml' 
kind: Service
metadata:  # necessário
  name: backend  # podemos escolher qualquer nome
spec:    # é o mais importante
## vc vai SELECIONAR OS __ PODS, E NÃO OS DEPLOYMENTS EM SI...
  selector:   # É ESSENCIAL.... E O SELECTOR DE 'Service's _FUNCIONA DE FORMA 1 POUCO DISTINTA DAQUELA VISTA NO SELECTOR DOS OBJECTS 'Deployment'... (pq aqui não há a decisão entre 'matchLabels' e 'matchExpressions', pq SEMPRE SERÁ A OPÇÃO 'matchLabels'...)
    app: second-app ##? OBS: podemos selecionar PODS QUE PERTENÇAM A 2 DEPLOYMENTS DISTINTOS _ NESSE MESMO SERVICE__ ...
  ports: # é uma lista, pq podemos expor vários ports...
    - protocol: 'TCP' ### é o default... 'conexão direta', maior confiabilidade, menor velocidade
      port: 80  ## port externa, alcançável pelo 'external world'...
      targetPort: 8080 ## port interna, dos nossos pods/containers...
    # - protocol: 'UDP'   ### como adicionar mais ports...
    #   port: 443
    #   targetPort: 443
  type: LoadBalancer ## pode ser também 'ClusterIP' (é o default) e 'NodePort'



---  # ESSE É O SEPARADOR ENTRE DIFERENTES RESOURCES, DENTRO DE 1 MESMO ARQUIVO

apiVersion: apps/v1
kind: Deployment # VALUES POSSÍVEIS: 'Deployment', 'Job', 'Service'
metadata: # key SUPER IMPORTANTE, nesses arquivos yaml do kubernetes
  name: second-app-deployment # será o NAME de nosso deployment, deployment object

spec: # É O 'MEAT' de nosso deployment ----> é a SPECIFICATION de nosso deployment (como o nosso deployment deve ser configurado)...
  replicas: 2 # '''O NÚMERO DE POD INSTANCES QUE QUEREMOS TER, COMO DEFAULT'''... --> o default DE VERDADE é '1', por sinal...

  selector: # é outra key _OBRIGATÓRIA, no seu 'deployment' object...
    # matchExpressions: ### mais complexo do que 'matchLabels'
    matchLabels: ### colocamos as labels dos PODS QUE QUEREMOS QUE SEJAM CONTROLADOS POR NOSSO DEPLOYMENT...
      app: second-app # pod que é criado/configurado logo abaixo... (dizemos que todos os pods que tenham as labels de 'app: second-app' e 'tier: backend' DEVEM SER CONTROLADOS POR NOSSO DEPLOYMENT)
      tier: backend


  template: # COM ESSA OPTION, DEFINIMOS 'O POD QUE DEVE SER CRIADO' (é tipo a parte de '--image=nothingnothings/first-kub-app' lá da APPROACH IMPERATIVE) --> E O TEMPLATE DE 1 DEPLOYMENT _ SEMPRE __ VAI DESCREVER 1 'POD' object...
    #kind: pod --> NÃO É NECESSÁRIO, PQ O 'kind' de algo nesteado/criado dentro de 1 object deployment é SEMPRE 1 POD..
    metadata: # cada object (1 pod é um object) sempre tem essa key de 'metadata'
      labels: # é basicamente a option de 'name', como em 'deployment'... entretanto, aqui é usada para 1 POD OBJECT...
        app: second-app ### PODERÍAMS COLOCAR QUAISQUER NOMES PARA ESSES 'key-value' pairs...
        tier: backend
    spec: #### esse será o SPEC DE NOSSO/NOSSOS POD/PODS (e não do deployment inteiro)... --> OBS:: PARA CADA 'DEPLOYMENT' PODEMOS TER APENAS 1 'TYPE' DE POD..
      containers: # é a key mais IMPORTANTE DO SPEC DE NOSSO/NOSSOS POD/PODS... (pode ser 1 container ou vários)....
        - name: second-nodejs-app # o nome de 1 de nossos containers...
          image: nothingnothings/kub-first-app:2 # a image que será usada, em 1 de nossos containers, dentro desse pod
        # - name: third-nodejs-app   #### é assim que adicionamos MAIS CONTAINERS AO NOSSO POD, tudo dentro do mesmo pod...
        #   image: nothingnothings/kub-second-app
        # - name: fourth-nodejs-app
        #   image: nothingnothings/kub-third-app ...
