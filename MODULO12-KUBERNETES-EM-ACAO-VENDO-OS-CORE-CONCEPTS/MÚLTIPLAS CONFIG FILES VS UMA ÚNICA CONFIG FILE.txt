













OK.. ALÉM DE FAZER CHANGES EASILY,


 
 PODEMOS FAZER 'MERGE'

 DE 



 MÚLTIPLAS FILES 

 EM 



 1 

 ÚNICA FILE,

 FACILMENTE...









POR EXEMPLO, AQUI,


PODERÍAMOS 



ARGUMENTAR QUE O SERVICE DE 


'service.yaml' 



TEM BASTANTE RELAÇÃO 



com 




o deployment de 'deployment.yaml'...














--> E TER MÚLTIPLAS FILES PODE SER O QUE VC QUER... --> PODE TER 


VANTAGENS,



PQ 




FICA CLARO 'O QUE É CONFIGURADO, EM QUE LUGAR'...










-----> OK.... MAS TALVEZ VC 

QUEIRA 


TER 

APENAS 

1 FILE,

COM 

TODAS AS COISAS 
RELATIVAS 

A ESSA FILE,

DENTRO DELA...










--> PARA DEMONSTRAR ISSO,

O PROFESSOR CRIA 1 ARQUIVO DE 'nome'




master-deployment.yaml 













--> DEPOIS ELE COPIA E COLA 


O 


CONTEÚDO DE 'deployment.yaml' 


DENTRO 





DESSE ARQUIVO...






DEPOIS, 


ELE 

COPIA 


E 

COLA 


O CONTEÚDO DE 

'service.yaml'

TAMBÉM...












-----> PODEMOS FAZER ISSO COM QUANTOS 'RESOURCES' DESEJARMOS;

COLOCAR 


TODOS ELES EM 1 MESMO ARQUIVO '.yaml'...













EX:

















## NADA IMPEDE QUE TENHAMOS MÚLTIPLOS RESOURCES (deployments, services, etc) EM 1 MESMO ARQUIVO... (mas é meio bagunçado)...

apiVersion: v1 # diferente de 'apps/v1', usada no 'deployment.yaml' 
kind: Service
metadata:  # necessário
  name: backend  # podemos escolher qualquer nome
spec:    # é o mais importante
## vc vai SELECIONAR OS __ PODS, E NÃO OS DEPLOYMENTS EM SI...
  selector:   # É ESSENCIAL.... E O SELECTOR DE 'Service's _FUNCIONA DE FORMA 1 POUCO DISTINTA DAQUELA VISTA NO SELECTOR DOS OBJECTS 'Deployment'... (pq aqui não há a decisão entre 'matchLabels' e 'matchExpressions', pq SEMPRE SERÁ A OPÇÃO 'matchLabels'...)
    app: second-app ##? OBS: podemos selecionar PODS QUE PERTENÇAM A 2 DEPLOYMENTS DISTINTOS _ NESSE MESMO SERVICE__ ...
  ports: # é uma lista, pq podemos expor vários ports...
    - protocol: 'TCP' ### é o default... 'conexão direta', maior confiabilidade, menor velocidade
      port: 80  ## port externa, alcançável pelo 'external world'...
      targetPort: 8080 ## port interna, dos nossos pods/containers...
    # - protocol: 'UDP'   ### como adicionar mais ports...
    #   port: 443
    #   targetPort: 443
  type: LoadBalancer ## pode ser também 'ClusterIP' (é o default) e 'NodePort'



---  # ESSE É O SEPARADOR ENTRE DIFERENTES RESOURCES, DENTRO DE 1 MESMO ARQUIVO

apiVersion: apps/v1
kind: Deployment # VALUES POSSÍVEIS: 'Deployment', 'Job', 'Service'
metadata: # key SUPER IMPORTANTE, nesses arquivos yaml do kubernetes
  name: second-app-deployment # será o NAME de nosso deployment, deployment object

spec: # É O 'MEAT' de nosso deployment ----> é a SPECIFICATION de nosso deployment (como o nosso deployment deve ser configurado)...
  replicas: 2 # '''O NÚMERO DE POD INSTANCES QUE QUEREMOS TER, COMO DEFAULT'''... --> o default DE VERDADE é '1', por sinal...

  selector: # é outra key _OBRIGATÓRIA, no seu 'deployment' object...
    # matchExpressions: ### mais complexo do que 'matchLabels'
    matchLabels: ### colocamos as labels dos PODS QUE QUEREMOS QUE SEJAM CONTROLADOS POR NOSSO DEPLOYMENT...
      app: second-app # pod que é criado/configurado logo abaixo... (dizemos que todos os pods que tenham as labels de 'app: second-app' e 'tier: backend' DEVEM SER CONTROLADOS POR NOSSO DEPLOYMENT)
      tier: backend


  template: # COM ESSA OPTION, DEFINIMOS 'O POD QUE DEVE SER CRIADO' (é tipo a parte de '--image=nothingnothings/first-kub-app' lá da APPROACH IMPERATIVE) --> E O TEMPLATE DE 1 DEPLOYMENT _ SEMPRE __ VAI DESCREVER 1 'POD' object...
    #kind: pod --> NÃO É NECESSÁRIO, PQ O 'kind' de algo nesteado/criado dentro de 1 object deployment é SEMPRE 1 POD..
    metadata: # cada object (1 pod é um object) sempre tem essa key de 'metadata'
      labels: # é basicamente a option de 'name', como em 'deployment'... entretanto, aqui é usada para 1 POD OBJECT...
        app: second-app ### PODERÍAMS COLOCAR QUAISQUER NOMES PARA ESSES 'key-value' pairs...
        tier: backend
    spec: #### esse será o SPEC DE NOSSO/NOSSOS POD/PODS (e não do deployment inteiro)... --> OBS:: PARA CADA 'DEPLOYMENT' PODEMOS TER APENAS 1 'TYPE' DE POD..
      containers: # é a key mais IMPORTANTE DO SPEC DE NOSSO/NOSSOS POD/PODS... (pode ser 1 container ou vários)....
        - name: second-nodejs-app # o nome de 1 de nossos containers...
          image: nothingnothings/kub-first-app:2 # a image que será usada, em 1 de nossos containers, dentro desse pod
        # - name: third-nodejs-app   #### é assim que adicionamos MAIS CONTAINERS AO NOSSO POD, tudo dentro do mesmo pod...
        #   image: nothingnothings/kub-second-app
        # - name: fourth-nodejs-app
        #   image: nothingnothings/kub-third-app ...



























--> PARA ISSO,



APENAS DEVEMOS ADICIONAR '---' (three dashes)





ENTRE A DEFINIÇÃO DE CADA 'OBJECT'/RESOURCE...
















--> OK... TEMOS ESSES 3 DASHES ENTRE TODOS NOSSOS RESOURCE DEFINITIONS...













--> E PODEMOS TER QUANTOS 


RESOURCE DEFINITIONS 

QUISERMOS,

DENTRO DESSA FILE...













OBS:::: SE VC COMBINAR 1 'SERVICE' E '1 DEPLOYMENT'




EM 1 MESMO ARQUIVO yaml,


É UMA BOA PRÁTICA 



COLOCAR O 'SERVICE'


ANTES 


___ DE QUALQUER DEPLOYMENT -----> PQ AÍ 




ESSE SERVICE VAI SER CRIADO ANTES... --> 















pq OS SERVICES SÃO CRIADOS, NOS ARQUIVOS '.yaml', 
DE CIMA PARA BAIXO (queremos que o service seja criado antes, para
 que já adicione os pods necessários, ao seu contexto)... 














--> O CÓDIGO FUNCIONARIA NA ORDEM REVERSA (deployments antes de services),



MAS 

ESSA É CONSIDERADA UMA BETTER PRACTICE... 


















SIDENOTE ------> É BEM IMPORTANTE TER EM MENTE 

QUE 

ESSES OBJECTS SÃO 

'LIVING ORGANISMS'


EM 1 CLUSTER -----> QUER DIZER QUE QUANDO 1 SERVICE 
É CRIADO,



ELE NÃO É 'SIMPLY ANALYZED AND CREATED ONCE',





E SIM 

VAI _ CONTINUAMENTE MONITORAR OS PODS 


QUE SÃO 

CRIADOS E REMOVIDOS NO SEU APP.... -> E SE 1 NOVO POD FOR CRIADO,





SE ESSE POD 


'MATCHEAR' AQUELE label selector de 'app: second-app',




ESSE POD 

SERÁ ADICIONADO 





AO SERVICE DE 'backend' (nesse exemplo) --> É POR ISSO QUE 

CRIAR 



OS 



'service'


ANTES É MAIS RECOMENDADO...












--> ok... agora vamos DELETAR OS NOSSOS RESOURCES ATIVOS,


PARA AÍ FAZER APPLY DO ARQUIVO 


'master-deployment'...








ex:










kubectl delete -f deployment.yaml -f service.yaml 



















--> EX:







PS A:\projeto15-DOCKER\MODULO12-KUBERNETES-EM-ACAO-VENDO-OS-CORE-CONCEPTS\primeiro-project-kubernetes> kubectl apply -f deployment.yaml -f service.yaml  
deployment.apps/second-app-deployment created
service/backend created
PS A:\projeto15-DOCKER\MODULO12-KUBERNETES-EM-ACAO-VENDO-OS-CORE-CONCEPTS\primeiro-project-kubernetes> kubectl delete -f deployment.yaml -f service.yaml 
deployment.apps "second-app-deployment" deleted
service "backend" deleted
PS A:\projeto15-DOCKER\MODULO12-KUBERNETES-EM-ACAO-VENDO-OS-CORE-CONCEPTS\primeiro-project-kubernetes>














TAMBÉM ISTO:





ex:





PS A:\projeto15-DOCKER\MODULO12-KUBERNETES-EM-ACAO-VENDO-OS-CORE-CONCEPTS\primeiro-project-kubernetes> kubectl apply -f '.\master-deployment(all-resources).yaml'     
service/backend created
deployment.apps/second-app-deployment created







e depois isto:






PS A:\projeto15-DOCKER\MODULO12-KUBERNETES-EM-ACAO-VENDO-OS-CORE-CONCEPTS\primeiro-project-kubernetes> kubectl delete -f '.\master-deployment(all-resources).yaml'
service "backend" deleted
deployment.apps "second-app-deployment" deleted

























FAZ SENTIDO...














se quisermos expor nosso pod no minikube,

devemos rodar 




minikube service backend 




('backend' é o nome do nosso service)...






aí podemos encontrar nossa running application naquela url..












--> É ASSIM QUE PODEMOS MERGEAR MÚLTIPLAS FILES EM APENAS 1 FILE...