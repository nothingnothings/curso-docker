












--> OK... AGORA QUE APRENDEMOS SOBRE AS FEATURES CRUCIAIS DOS VOLUMES,



'REGULAR VOLUMES',



'PERSISTENT VOLUMES'


E 



'PERSISTENT VOLUME CLAIMS',












DEVEMOS VER AS 'ENVIRONMENT VARIABLES'....










ISSO PQ ENVIRONMENT VARIABLES IMPORTAM EM  1 MONTE DE APPS...

















--> VEREMOS NO NOSSO APP...











--> O FOLDER DE 'story'.... ----> 





O FOLDER EM QUE ARMAZENAMOS O ARQUIVO DE 'text.txt'...












-> ISSO ESTÁ HARDCODADO NO NOSSO CÓDIGO...










--> CERTO... MAS O FATO DE QUE 'VAMOS ARMAZENAR ESSE ARQUIVO DENTRO DO FOLDER DE "story" ' 



ESTÁ ESCRITO 



LÁ NO NOSSO 'deployment.yaml',






como visto aqui:








      containers:
        - name: my-story-app
          image: nothingnothings/my-story-app:latest
          volumeMounts: ## precisamos dessa option/key para DEFINIR QUAIS VOLUMES DEVERÃO SER MONTADOS EM ALGUM DE NOSSOS CONTAINERS, NESSE POD...
            - mountPath: /app/story ## QUEREMOS QUE NOSSA DATA/DATA DO USUÁRIO SEJA 'BINDADA' A ESSE INTERNAL PATH, DENTRO DE NOSSO CONTAINER (é exatamente como 1 named volume)....
              name: story-volume













- mountPath: /app/story















-> ESSE É O FOLDER QUE NÓS FAZEMOS 'SAVE',

COM A AJUDA DE 1 

VOLUME...












-> O PROFESSOR DIZ QUE TALVEZ SEJA MELHOR 








DEFINIR ESSE EXACT FOLDER NAME AQUI,



no nosso arquivo yaml,


E AÍ 


UTILIZAR 


ESSE VALUE/VARIÁVEL





LÁ DENTRO DO 'app.js',







com aquele código de 'process.env.XXX'...









--> E APRENDEMOS SOBRE O APPLY DE ENVIRONMENT VARIABLES COM 

O DOCKER E DOCKER-COMPOSE...














--> E É CLARO QUE O KUBERNETES TAMBÉM SUPORTA ENVIRONMENT VARIABLES...













--> O PROFESSOR COMEÇA COM ISTO, LÁ EM 'app.js':








//TODO DEFINIDO LÁ NO 'deployment.yaml', essa env variable...
const filePath = path.join(__dirname, process.env.STORY_FOLDER, 'text.txt');



















OK... AGORA PRECISAMOS GARANTIR QUE 


ESSA ENVIRONMENT VARIABLE SERÁ SETTADA A 1 FOLDER NAME QUE QUEREMOS USAR __ NO MOMENTO EM QUE 

DEPLOYAMOS 

NOSSO CLUSTER...
















--> PRECISAMOS PROVIDENCIAR 1 VALUE PARA ESSE ENV VARIABLE....













--> PARA ISSO, VC DEVE IR ATÉ 'deployment.yaml'



E, 



na config dos containers,





vc deve 

COLOCAR A KEY DE 'env'...





TIPO ASSIM:








          #### TODO uso de ENV VARIABLES nos nossos containers
          env:
            - name: 












OK... DENTRO DE 'env',

VC 

DEVE 

COLOCAR 


A LISTA DE ENVIRONMENT VARIABLES QUE VC VAI QUERER USAR...











--> o professor coloca 'name:',




QUE COLOCA COMO 'STORY_FOLDER',








E DEPOIS COLOCA 'value',
que 
vai 

providenciar o VALOR 




DESSA ENV VARIABLE,
TIPO ASSIM:















         env:
            - name: STORY_FOLDER
              value: 'story'












CERTO...








BEM SIMPLES.. COM ISSO, EXTERNALIZAMOS ESSE FOLDER NAME,

E O TORNAMOS MAIS FLEXÍVEL...










AGORA SE QUISERMOS 


TROCAR O FOLDER NAME,




BASTARÁ 




TROCAR O VALUE DESSA ENV VARIABLE 


NO 

'deployment.yaml',


SEM PRECISAR ALTERAR TUDO LÁ NO NOSSO CÓDIGO....
















-----> ok.... O PROFESSOR UPDATA A IMAGE, e aí rebuildamos tudo de novo,

e aí 

fazemos deploy...











O NOSSO CÓDIGO FICA ASSIM:

















apiVersion: apps/v1
kind: Deployment
metadata:
  name: story
spec:
  selector:
    matchLabels:
      story: story
  # replicas: 1
  replicas: 2 ### o volume type de 'emptyDir' NÃO FUNCIONA MT BEM COM MÚLTIPLAS INSTANCES DE 1 GIVEN POD...
  template:
    metadata:
      labels:
        story: story
    spec: ###### SPECIFICATION DE 1 POD/NOSSO POD...
      containers:
        - name: my-story-app
          image: nothingnothings/my-story-app:latest
          imagePullPolicy: Always
          #### TODO uso de ENV VARIABLES nos nossos containers
          env:
            - name: STORY_FOLDER
              value: 'story'
          volumeMounts: ## precisamos dessa option/key para DEFINIR QUAIS VOLUMES DEVERÃO SER MONTADOS EM ALGUM DE NOSSOS CONTAINERS, NESSE POD...
            - mountPath: /app/story ## QUEREMOS QUE NOSSA DATA/DATA DO USUÁRIO SEJA 'BINDADA' A ESSE INTERNAL PATH, DENTRO DE NOSSO CONTAINER (é exatamente como 1 named volume)....
              name: story-volume
          resources:
            limits:
              memory: '256Mi'
              cpu: '500m'
      volumes: # VOLUMES, NO KUBERNETES, SÃO ANEXADOS AOS NOSSOS PODS (e não aos containers...) --> isso quer dizer que TODOS OS CONTAINERS, NO NOSSO POD, serão capazes de usar esse volume...
        - name: story-volume
          # HÁ MUITOS E MUITOS TYPES DE VOLUMES (Aws, azure, gcp)... o professor escolhe 'emptyDir'...
          ### ! 'emptyDir' só é útil se você:
          ### 1) TIVER 1 ÚNICO POD em que quer armazenar coisas
          ### 2) SE VC QUISER QUE A DATA SEJA PERDIDA A CADA RESTART DO POD...
          ### 3) SE VC QUER TESTAR ALGUMA COISA, ESTÁ APENAS 'DEVELOPING AND TRYING OUT THINGS'
          ### TODO 'emptyDir' --> É 'POD-SPECIFIC' (específico a apenas 1 pod em 1 worker/master node... não pode ser usado em outros pods, nem outros nodes)....
          # ! emptyDir: {} ### isso significa que queremos usar o type emptyDir 'AS IT IS', sem ter uma configuração específica...

          ## TODO  'hostPath' --> É 'NODE-SPECIFIC' (específico a 1 worker/master node... não pode ser usado em outros nodes)...
          # hostPath: ### 'hostPath' é o outro VOLUME TYPE. ELE FUNCIONA 1 POUCO COMO UMA BIND MOUNT
          #   ## hostPath --> requer a key de 'path', que é usada para especificar o PATH NA 'HOST MACHINE' (no nosso worker node, essencialmente)...
          #   path: /data ### ? --> com isso, TUDO QUE ESTÁ DENTRO DO PATH DE '/data', no folder de 'data', NO NOSSO WORKER NODE/HOST MACHINE, será compartilhado com NOSSOS CONTAINERS NESSES PODS (no caso, com o container de 'my-story-app') --> e todos os containers que tiverem MONTADO esse volume vão poder se aproveitar/usar dessa data...
          #   #### outros values possíveis para type são 'Directory', 'File', 'FileOrCreate', Socket
          #   type: DirectoryOrCreate ### ? COM ESSA KEY, especificamos 'COMO DEVE SER HANDLADO O PATH/FOLDER desse volume' --> com 'DirectoryOrCreate',  dizemos que 'ESSE PATH DEVERÁ SER 1 EXISTING DIRECTORY'... se não existir no momento, CRIE 1 NOVO DIRECTORY COM ESSE NOME..
          persistentVolumeClaim:   ### isso deve ser usado junto com o arquivo yaml de 'persistent-volume-claim'... //////// E 'PERSISTENT-VOLUMES', junto dos 'PERSISTENT-VOLUME-CLAIMS' (que são usados para acessar os persistent volumes) são o VOLUME TYPE MAIS USADO, NO KUBERNETES... PQ SÃO 1 ARMAZENAMENTO CENTRAL, que precisa ser definido apenas 1 única vez...
            claimName: persistent-volume-claim  ### ? E NADA TE IMPEDE DE USAR ESSE 'persistent-volume-claim' EM DIFERENTES LOCAIS DE SEU APP (em outros pods, em outros nodes)...














# o type 'emptyDir'
# VAI SIMPLESMENTE CRIAR 1 'NEW EMPTY DIRECTORY'
# __ SEMPRE QUE O POD STARTAR.. --> E AÍ ELE VAI __ MANTER
# ESSE DIRECTORY __ VIVO,
# E CHEIO DE DATA,
# DESDE QUE O POD FIQUE VIVO... ------> CERTO... -----> OS CONTAINERS
# PODEM ENTÃO
# FAZER
# '''WRITE''' A ESSE DIRECTORY.... -------> E, SE, ENTÃO,
# OS CONTAINERS SÃO __ RESTARTADOS OU REMOVIDOS,
# ___ A DATA VAI SOBREVIVER... -->  MAS __ SE O POD __ FOR REMOVIDO,
# O __ DIRECTORY INTEIRO SERÁ REMOVIDO....

#E, QUANDO 1 NOVO POD FOR CRIADO, ESSE EMPTY DIRECTORY SERÁ RECRIADO....










-----------------------------------------------







aí ele aplica as changes ao nosso deployment,

com 




kubectl apply -f deployment.yaml










ok.... funcionou...





TUDO FUNCIONA, MAS AGORA COM ENV VARIABLES...