version: '3.8'
services:
  #? PRIMEIRAMENTE, OS 'APP CONTAINERS' (que sempre ficarão rodando, no fundo... pq precisams handlar os requests, por ser um server)..
  #SERVER --> SERÁ RESPONSÁVEL PELO RECEBIMENTO DOS INCOMING REQUESTS E SUA DATA, QUE SERÁ REPASSADA AO 'PHP INTERPRETER' ( container 'PHP')...
  server:
    # outsourceado para nossa DOCKERFILE de 'nginx.dockerfile'..
    # image: 'nginx:latest'
    build: 
      #context --> '''SETs THE FOLDER IN WHICH THE DOCKERFILE WILL BE BUILT (and found)''...
      # com '.', ampliamos o alcance do catch de changes de nosso container, pq com '.' ele será o ROOT PROJECT FOLDER (o folder de 'php-laravel-docker-setup', em que o arquivo docker-compose se encontra)
      context: .
      dockerfile: 'dockerfiles/nginx.dockerfile'
    ports:
      - '8000:80'
    #SIM, É POSSÍVEL BINDAR APENAS 1 ÚNICO ARQUIVO EM 1 FOLDER, EM VEZ DE 1 FOLDER INTEIRO...
    volumes:
      # DEVEMOS BINDAR ESSA PASTA LOCAL, COM 1 BIND MOUNT, A ESSE PATH INTERNO DO CONTAINER, QUE É '/etc/nginx/nginx.conf' (pq, sim, é apenas esse arquivo que interessa, dentro daqeula pasta)..
      # ESSA CONFIG FILE É NECESSÁRIA PARA FAZER O WEBSERVER NGINX FUNCIONAR...
      - './nginx/nginx.conf:/etc/nginx/conf.d/default.conf:ro'
      - './src:/var/www/html'
    depends_on:
      - php
      - mysql
    #PHP --> RESPONSÁVEL PELO RUN E EXECUTE DE NOSSO CÓDIGO PHP (também o código laravel, pq o laravel é um framework php).
    # VAMOS USAR 1 IMAGE CUSTOM, criada por nós...
  php:
    # sintaxe mais complexa de build...
    build:
      # context: './dockerfiles'
      # dockerfile: 'php.dockerfile' # 'DELEGATED' vai MELHORAR 1 POUCO A PERFORMANCE, PQ ESSE CONTAINER DE 'php' NÃO DEVERÁ WRITE BACK A ESSE FOLDER __ COM TANTA FREQUÊNCIA ASSIM, E AS COISAS QUE ELE FAZ WRITE NÃO PRECISAM SER REFLETIDAS NA HOST MACHINE INSTANTANEAMNETE.. (pq ELE NÃO VAI WRITE _ ALGUMA _ COISA QUE PRECISAMOS __ ACESSAR INSTANTANEAMENTE NA HOST MACHINE) 
      context: .
      dockerfile: 'dockerfiles/php.dockerfile'
    volumes:
      - './src:/var/www/html:delegated'
    ports:
      - '3000:9000'
    #MYSQL --> é a database MYSQL
  mysql:
    #? DEPOIS DISSO, OS 'UTILITY CONTAINERS' (que SÃO RODADOS, OCASIONALMENTE, DURANTE O RUNTIME, POR NÓS MESMOS, COM 'docker-compose run xxx xxx')..
    image: mysql:5.7
    env_file:
      - ./env/mysql.env
  #'COMPOSER' é TIPO O 'npm do PHP', é usado para CRIAR PROJETOS E INSTALAR DEPENDENCIES PHP (é usado para CRIAR O APP LARAVEL, POR EXEMPLO)...
  composer:
    # 'ARTISAN' É UMA FERRAMENTA DO 'laravel', é o LARAVEL ARTISAN, que é usado para fazer coisas como 'RODAR MIGRATIONS CONTRA NOSSA DATABASE', dentre outras...
    build:
      context: './dockerfiles'
      dockerfile: composer.dockerfile
    volumes:
      - ./src:/var/www/html
  artisan:
    # é usado para fazer coisas como 'POPULATE THE DATABASE' com migrations, seeds, etc.. é o LARAVEL ARTISAN...
    # USAREMOS A MESMA IMAGE DO PHP, BÁSICA...
    # comando que usaremos, no terminal: 'docker-compose run --rm artisan migrate'
    build:
      context: '.'
      dockerfile: 'dockerfiles/php.dockerfile'
    volumes:
      - ./src:/var/www/html
    # ESSA OPTION/KEY NOS DEIXA __ ADD OU OVERWRITE 1 COMANDO DE 'entrypoint' na DOCKERFILE que é usada em build/image, se __ ESSE 'CMD []' ou 'entrypoint []' EXISTIR DENTRO DAQUELA DOCKERFILE, É CLARO...
    # com esse 'UTILITY CONTAINER', vamos querer EXECUTAR ESSE ARQUIVO 'artisan'...
    entrypoint: [ "php", "/var/www/html/artisan" ]
    # colocamos o 'npm' PQ VAMOS RODAR COMANDOS COMo 'npm install', 'npm  init', etc etc...
  npm:
    image: node:14
    # working_dir é a 'WORKDIR' instruction das dockerfiles... e pode ser escrita aqui....
    working_dir: /var/www/html
    # stdin_open e tty também são instructions das dockerfile, e também podem ser escritas aqui, no arquivo docker-compose.yaml...
    stdin_open: true
    tty: true
    # entrypoint TAMBÉM É UMA INSTRUCTION DAS DOCKERFILE, e pode ser escrita aqui...
    entrypoint: [ "npm" ]
    # run --> É UMA INSTRUCTION DAS DOCKERFILE... MAS NÃO PODE SER ESCRITA NOS ARQUIVOS 'docker-compose'...
    # copy --> É UMA INSTRUCTION DAS DOCKERFILE... MAS NÃO PODE SER ESCRITA NOS ARQUIVOS 'docker-compose'...
    volumes:
      - ./src:/var/www/html
