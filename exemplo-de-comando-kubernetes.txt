








PARA SE COMUNICAR COM O KUBERNETES:








kubectl xxxx (xxxx = 'comandos')..









ex:










kubectl create deployment 


























MINIKUBE (ambiente dummy, para testar a conexão com o kubernetes... usa virtual machine no seu pc)...




ex:








minikube start --driver=hyperv




minikube status...





















kubectl get deployments ------> VISUALIZAMOS QUANTOS DEPLOYMENTS TEMOS NO CLUSTER A QUE 


NOS CONECTAMOS...













kubectl get pods --> VEREMOS TODOS OS PODS de nossos deployments, criados pelos deployments...















EX:








kubectl delete deployment <deployment-name>










EX:







kubectl create deployment my-first-deployment --image=nothingnothings/kub-first-app









--> COLOCAMOS em '--image' A NOSSA URL DO DOCKERHUB...






















minikube dashboard ---------> ABRE A DASHBOARD do minikube..
















EX:













 TEMOS 

  1 COMANDO 

  AINDA MAIS CONVENIENTE 

  PARA __ EXPOR__ OS PODS _ CRIADOS POR 1 DEPLOYMENT __ AO MUNDO EXTERIOR__ ----->








É O COMMAND DE  'kubectl expose'












--> esse comando faz o que diz o nome,

ele 

EXPÕE 1 POD, CRIADO POR 1 DEPLOYMENT,




POR MEIO DO CREATE DE 1 SERVICE....










kubectl expose deployment <deployment-object-name> --port=xxxx

















ex:









kubectl expose deployment first-app --port=8080


















também precisamos da option de '--type' (--type e --port são options obrigatórias)..








ex:










kubectl expose deployment first-app  --type=ClusterIP --port=8080








('ClusterIP' é o type DEFAULT de coisa que vc vai querer expor)... ----> O 'ClusterIP'



faz com que 


SEU DEPLOYMENT FIQUE 'REACHABLE' APENAS __ NO LADO DE DENTRO DO SEU CLUSTER (E não do lado de fora)..





A UTILIDADE DE 'ClusterIP' é que ele te dá um 'UNCHANGABLE ADDRESS',


que não vai mudar, e que pode ser usado no contexto interno do kubernetes cluster... 











--> OK... ALÉM DE 'ClusterIP',






temos 





'NodePort',



QUE 



ACTUALLY SIGNIFICA 






''''ESSE DEPLOYMENT DEVERÁ SER ___ EXPOSTO COM A AJUDA DO IP ADDRESS 

DO __ WORKER__ NODE __ __ EM QUE ELE ESTÁ SENDO RODANDO''''' 







--> ISSO QUER DIZER QUE O 'NodePort' VAI DEIXAR ESSE __ DEPLOYMENT SER ACESSÍVEL 

DO LADO DE FORA 



DO CLUSTER...








MAS MELHOR DO QUE ISSO,
 

 TEMOS 

 O 

 TYPE DE 'LOAD BALANCER' ('LoadBalancer') --> ESSE TYPE USA UM 'LOAD BALANCER',




QUE __ DEVERÁ EXISTIR (Vc precisa settar) NA SUA INFRAESTRUTURA,

NA INFRAESTRUTURA  EM QUE VC RODARÁ SEU CLUSTEr (aws, por exemplo)...








ex:







SE ESCOLHEMOS 'LoadBalancer' como type,  é esse load balancer que vai gerar 

1 

'unique address' para esse service... mas mais do que isso,

ele vai 

também 

'DISTRIBUTE INCOMING TRAFFIC EVENLY ACROSS ALL PODS WHICH ARE PART OF THIS 
SERVICE'...















--> COMO TEMOS APENAS 1 POD,

NÃO TEMOS MÚLTIPLAS INSTANCES DESSE POD,




TER  O TYPE DE 'LOADBALANCER' AQUI NÃO FAZ TANTA DIFERENÇA... MAS EM PRODUCTION,


COM MÚLTIPLAS INSTANCES DESSE POD,




ISSO IMPORTARIA....








EX:











--> CERTO.... MAS O LOAD BALANCER,



ESSE TYPE DE 'LoadBalancer',



SÓ PODE SER USADO  __ SE 


O SEU CLUSTER E A INFRAESTRUTURA EM QUE O CLUSTER RODA 


SUPORTAM ESSA TECNOLOGIA...















EX:









kubectl expose deployment <deployment-name> --type/LoadBalancer --port=8080













--> ISSO TUDO COM O APPROACH IMPERATIVE, É CLARO...


















kubectl get services --> mostra os SERVICES ATUALMENTE CRIADOS/SETTADOS...











VEREMOS ISTO:












C:\WINDOWS\system32>kubectl get deployments
NAME                  READY   UP-TO-DATE   AVAILABLE   AGE
my-first-deployment   1/1     1            1           5h4m

C:\WINDOWS\system32>kubectl expose deployment --type=LoadBalancer --port=8080
error: resource(s) were provided, but no name was specified

C:\WINDOWS\system32>kubectl expose deployment my-first-deployment --type=LoadBalancer --port=8080
service/my-first-deployment exposed

C:\WINDOWS\system32>kubectl get services
NAME                  TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
kubernetes            ClusterIP      10.96.0.1       <none>        443/TCP          5h48m
my-first-deployment   LoadBalancer   10.101.118.96   <pending>     8080:30107/TCP   9s

C:\WINDOWS\system32>











EX:










O de baixo,



'kubernetes',





TEM O TYPE DE 'CLUSTERIP',



E É 


1 SERVICE QUE É CRIADO AUTOMATICAMENTE, PELO PRÓPRIO KUBERNETES...










EX:












-> CERTO...








MAS EM 'my-first-deployment' 





ENXERGAMOOS O SERVICE PARA O _ PRIMEIRO DEPLOYMENT... --> TEMOS O TYPE DE 

'LOADBALANCER',



e 



o 'CLUSTERIP',

que não nos ajudará...
















EX:











--> CERTO...





TEMOS TAMBÉM O 'EXTERNAL IP' ---------> SE ISSO FOSSE DEPLOYADO EM 1 'CLOUD PROVIDER',


VERÍAMOS 1 VALOR ALI NO 'EXTERNAL-IP'... MAS COMO 


ESTAMOS NO MINIKUBE,


ESSE NEGÓCIO SEMPRE FICARÁ COMO 'PENDING'...













minikube service --> esse comando existe  SÓ NO MINIKUBE... serve para MAPPEARMOS 

nosso service do deployment a alguma PORT no nosso computador local/local machine ....







('minikube service' NÃO EXISTE EM CLOUD PROVIDERS, pq lá vc já vai ter 1 'external ip' 

válido, a essa altura)












EX:












-> ok... rodamos 'minikube service my-first-deployment'...



--> ESSE COMANDO VAI NOS DAR 1 TABLE COM 1 ADDRESS, QUE ENTÃO PODEREMOS USAR PARA 'VIEW'

A NOSSA APPLICATION...





EX:






C:\WINDOWS\system32>kubectl get services
NAME                  TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
kubernetes            ClusterIP      10.96.0.1       <none>        443/TCP          5h48m
my-first-deployment   LoadBalancer   10.101.118.96   <pending>     8080:30107/TCP   9s

C:\WINDOWS\system32>minikube service my-first-deployment
|-----------|---------------------|-------------|----------------------------|
| NAMESPACE |        NAME         | TARGET PORT |            URL             |
|-----------|---------------------|-------------|----------------------------|
| default   | my-first-deployment |        8080 | http://172.22.142.92:30107 |
|-----------|---------------------|-------------|----------------------------|
* Opening service default/my-first-deployment in default browser...












EX:















DIGAMOS QUE __ NÃO TEMOS AUTO-SCALING ATIVADO... --> ISSO QUER DIZER QUE 


O 



KUBERNETES NÃO VAI CRIAR MAIS OU MENOS PODS... 










-> MAS DIGAMOS QUE _ TEMOS CERTEZA DE QUE 

'TEREMOS MAIS TRAFFIC INCOMING' --> POR ISSO DIGAMOS QUE 

QUEREMOS 

QUE 






NOSSO POD, E O CONTAINER DENTRO DESSE POD,




RODANDO MAIS DO QUE 1 VEZ,

E SIM 





3 VEZES... -------> PODEMOS OBTER ESSE RESULTADO COM O COMANDO 


'kubectl scale ....'







PARA ISSO,

ESCREVEREMOS:









kubectl scale deployment/my-first-deployment 














É ASSIM QUE IDENTIFICAMOS 


OS NOSSOS DEPLOYMENTS (com 'deployment/nome-do-deployment')...











OK... ISSO FEITO,

ADICIONAMOS 






A FLAG DE '--replicas'



PARA SIMPLESMENTE 


ESPECIFICAR  






__ QUANTAS__ INSTANCES,


QUANTOS PODS,


QUEREMOS TER...

















--> por exemplo, podemos querer settar o número de pods como '3'...






ex:







kubectl scale deployment/my-first-deployment --replicas=3











EX:








--> OK.... AGORA TEMOS NOSSOS 2 PODS EXTRAS RODANDO...














-> CERTO... E ELES ESTÃO RODANDO O MESMO CONTAINER DO PRIMEIRO POD...












E, COMO ESTAMOS RODANDO 1 'LOAD BALANCER', 





O TRAFFIC DE NOSSO APP _ TAMBÉM SERÁ DISTRIBUÍDO 'EVENLY' 






AO __ LONGO DESSES DIFERENTES PODS E OS CONTAINERS RODANDO NELES...


















-> CERTO... E ELES ESTÃO RODANDO O MESMO CONTAINER DO PRIMEIRO POD...





--> podemos testar isso 



com a route de '/error'...













--> PODEMOS ENTRAR NA PAGE DE '/error' 1 vez,




e aí 




SAIR DESSA  PAGE...









-> SE FIZERMOS ISSO E CHECARMOS A DASHBOARD DO MINIKUBE,

VEREMOS QUE 





__ APENAS 1 DAS INSTANCES/PODS ESTARÁ 'DOWN',

AO PASSO QUE 


OUTROS 2 PODS AINDA ESTARÃO RODANDO....









-_> COMO OS 2 OUTROS PODS AINDA ESTÃO RODANDO ,


AINDA SOMOS CAPAZES DE VISITAR A NOSSA PAGE,

COMO SE NADA TIVESSE ACONTECIDO (impressionante)...















--> o pod que foi 'TERMINATED' eventualmente vai restartar,



MAS O QUE INTERESSA É QUE O INCOMING TRAFFIC VAI SER REDIRECIONADO 


A OUTRO POD...











--> ISSO QUER DIZER QUE O TRAFFIC 

NÃO VAI SER DIRECIONADO A 1 MESMO POD O TEMPO INTEIRO,



PQ 

ELE _ VAI __ SER DISTRIBUÍDO AO LONGO DE NOSSOS DIFERENTES PODS...











--> ISSO QUER DIZER QUE O SCALING,

MESMO QUANDO NÃO ACONTECE AUTOMATICAMENTE,


É OUTRA FEATURE MT ÚTIL QUE GANHAMOS, COM O KUBERNETES...










EX:









PODEMOS 


RODAR 


'kubectl set',


PARA _ UPDATAr_ _ NOSSO 





DEPLOYMENT...








EX:










kubectl set ----------> PODEMOS COLOCAR 



'kubectl set image',









PARA __ SETTAR 1 NOVA IMAGE PARA __ 1 DEPLOYMENT ESPECÍFICO...












-> BASTA ESCREVER 




kubectl set image/nome-do-seu-deployment...






EX:



kubectl set image deployment/my-first-deployment












--> MAS É CLARO QUE AGORA PRECISAMOS 


COMUNICAR AO KUBERNETES ''''QUAL SERÁ ESSA NOVA IMAGE'''....














PARA ISSO, TEMOS QUE ESPECIFICAR BEM:



kubectl set image deployment/my-first-deployment kub-first-app=nothingnothings/kub-first-app:2













PARA VERIFICAR SE SEU UPDATE FOI APLICADO,





O 'CURRENT UPDATING STATUS',


VC DEVE EXECUTAR 

'kubectl rollout status deployment/my-first-deployment'







--> se seu update deu certo, você verá 'sucessfully rolled out!'









MINIKUBE RESTART (em caso de problemas):









minikube delete 




minikube start --container-runtime=containerd










---------------------------------------












 COMO ESSA IMAGE COM TAG DE 'dummy'

 NÃO EXISTE,




 O KUBERNETES VAI FAZER DEPLOY DE 1 IMAGE QUE NÃO EXISTE,



 ACARRETANDO EM UM _ERRO_...










basta escrever assim:





kubectl set image deployment/my-first-deployment kub-first-app=nothingnothings/dummy:dummy 


'image updated' (no terminal)







-> depois:




'kubectl status deployment'


'waiting for deployment rollout to finish: 1 old replicas are pending termination'...

















--> OK... PARECE QUE ESSA MENSAGEM DE 


'waiting for deployment rollout to finish: 1 old replicas are pending termination'...









SIGNIFICA QUE 




__ SEU DEPLOYMENT NÃO ESTÁ FUNCIONANDO... ESTAMOS 

'WAITING FOR DEPLOYMENT ROLLOUT TO FINISH'...











-> e as 'old replicas are shutting down'...










--> e isso está  em loop infinito...









OK... MAS SE VISUALIZAMOS 

NOSSO DASHBOARD, NO BROWSER,

VEREMOS QUE 


A REPLICA ANTIGA NÃO ESTÁ 'TERMINATING'




JUSTAMENT PQ 



O 'NEW POD' 


NÃO ESTÁ STARTING UP SUCCESSFULLY... --> ISSO PQ __ eLE ESTÁ 



COM PROBLEMAS QUANTO AO 'PULL' DA IMAGE...








-> EX:


Failed to pull image "nothingnothings/dummy:dummy": rpc
 error: code = Unknown desc = failed to pull and unpack image
  "docker.io/nothingnothings/dummy:dummy": failed to resolve reference
   "docker.io/nothingnothings/dummy:dummy": pull access denied, 
   repository does not exist or may require authorization: server message:
    insufficient_scope: authorization failed












--------> ok... é bem bom esse comportamento do kubernetes,


esse 
'ROLLING UPDATE',



QUE 



FAZ COM QUE O ÚLTIMO POD NÃO SEJA 'SHUT DOWN'


ANTES DO NOVO POD FICAR 'UP AND RUNNING'...





















OK, E COMO PODEMOS FAZER 'ROLLBACK' DE 1 DEPLOYMENT QUE NÃO DEU CERTO?








com este comando:



kubectl rollout undo deployment/my-first-deployment









'kubectl rollout undo deployment/xxxxxx' 
















-------> MAS SE DESEJAMOS IR 'BACK'


___A UM DEPLOYMENT AINDA MAIS ANTIGO,





NÃO SÓ AO 'PREVIOUS ONE',



MAS AINDA ALÉM,




_PODEMOS __ DAR 1 OLHADA NA NOSSA 'DEPLOYMENT HISTORY',


COM O COMANDO 
DE 



'kubectl rollout history deployment/my-first-deployment' 







EX:





C:\WINDOWS\system32>kubectl rollout history deployment/my-first-deployment
deployment.apps/my-first-deployment
REVISION  CHANGE-CAUSE
1         <none>
3         <none>
4         <none>














PODEMOS TAMBÉM  USAR A OPTION DE '--revision=xxx',

para 

TER MAIS INFORMAÇÕES SOBRE 1 GIVEN REVISION (como o label da revision, a image que foi utilizada e quebrou o app, etc)





C:\WINDOWS\system32>kubectl rollout history --revision=3 deployment/my-first-deployment
deployment.apps/my-first-deployment with revision #3
Pod Template:
  Labels:       app=my-first-deployment
        pod-template-hash=678ffbf459
  Containers:
   kub-first-app:
    Image:      nothingnothings/dummy:dummy
    Port:       <none>
    Host Port:  <none>
    Environment:        <none>
    Mounts:     <none>
  Volumes:      <none>




------------------------------------





OK... ISSO NOS MOSTRA:






1) QUAL IMAGE FOI USADA ('nothingnothings/dummy:dummy') -----> COM ISSO, É POSSÍVEL VER QUAL IMAGE 'BROKE'...






2) OUTRAS COISAS, não tão úteis...















-> MAS SE VISUALIZAMOS A REVISION 1,

veremos que ela usou a image original...

















OK.... MAS COMO PODEMOS FAZER 'rollout undo' (ROLLBACK)




A 


1 DEPLOYMENT ESPECÍFICO DE NOSSO APP?








fazemos isso com o comando de 




'''''''

kubectl rollout undo deployment/my-first-deployment --to-revision=
''''''















OU SEJA, PRECISAMOS DESSA OPTION DE '--to-revision'...





-> NO NOSSO CASO, COLOCAREMOS '1'...





ex:


'''''''
kubectl rollout undo deployment/my-first-deployment --to-revision=1
''''''















EX:













--> COM ISSO, JÁ NOS APROFUNDAMOS 1 POUCO MAIS COM O KUBERNETES...












--> o professor acha super importante que 


visualizemos o que o kubernetes faz por nós...














-> e esse POD MANAGEMENT,

AUTOMATIC CREATION E REMOVAL, RESTART DE PODS E CONTAINERS,


E 


O 
'ROLLBACK DE DEPLOYMENTS',





e etc,


TODAS ESSAS SÃO FEATURES SUPER 


ÚTEIS,



E QUE DEIXAM SUA VIDA MT MAIS FÁCIL SE VC ESTÁ 


FAZENDO DEPLOY DE GRANDES APPS A GRANDES CLUSTERS....














--> OK.... MAS JÁ BRINCAMOS BASTANTE COM ESSE IMPERATIVE APPROACH...






AGORA TROCAREMOS DESSE 'IMPERATIVE  APPROACH'

PARA 



1 

DECLARATIVE APPROACH.. --> ISSO VAI DEIXAR O TRABALHO COM O KUBERNETES BEM MAIS SIMPLES...














-> OK... PRIMEIRAMENTE,

O PROFESSOR VAI DELETAR O NOSSO SERVICE E 

DEPLOYMENT DE 'my-first-deployment'...













CERTO.... NOSSOS PODS E DEPLOYMENT DESAPARECERAM...










---------------------------------------------------






TUDO ESCRITO ACIMA __ SE APLICA AO 'IMPERATIVE APPROACH'...

















MAS QUANTO AO 'DECLARATIVE APPROACH',


TEMOS APENAS 1 COMANDO ESSENCIAL, QUE É EST 'KUBECTL APPLY'...














A CONFIG FILE É USADA PARA DEFINIR NOSSO 

'DESIRED TARGET STATE',


E SEMPRE QUE 

A
 APLICARMOS,


 O
  KUBERNETES VAI USAR 

  ESSE TARGET STATE



__ E FAZER __ 'WHATEVER IT TAKES'  




PARA FAZER ESSE TARGET STATE VIRAR O CURRENT STATE...








E SE NÓS, POR EXEMPLO,

 

 MUDARMOS __ 1 CONFIG FILE E A REAPLICARMOS,







 O KUBERNETES  VAI ANALISAR ' O QUE MUDOU',



 E AÍ 


 VAI 


 FAZER AS APPROPRIATE CHANGES NO NOSSO RUNNING CLUSTER 


 E NA 
 RUNNING APPLICATION...





 --> ISSO QUER DIZER QUE O 'kubectl apply'
  


  

  É COMPARÁVEL AO 'docker compose',

  DE CERTA FORMA,


  PQ AGORA 

  PODEMOS 

  USAR NOSSAS PRÓPRIAS 


  CONFIGURATION FILES,


  SEM TER DE RODAR 1 MONTE DE COMANDOS INDIVIDUAIS...





--> é por isso que o comando mais utilizado será 


'''''''''


kubectl apply -f config.yaml





'''''''''