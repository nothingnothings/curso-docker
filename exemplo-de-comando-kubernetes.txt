








PARA SE COMUNICAR COM O KUBERNETES:








kubectl xxxx (xxxx = 'comandos')..









ex:










kubectl create deployment 


























MINIKUBE (ambiente dummy, para testar a conexão com o kubernetes... usa virtual machine no seu pc)...




ex:








minikube start --driver=hyperv




minikube status...





















kubectl get deployments ------> VISUALIZAMOS QUANTOS DEPLOYMENTS TEMOS NO CLUSTER A QUE 


NOS CONECTAMOS...













kubectl get pods --> VEREMOS TODOS OS PODS de nossos deployments, criados pelos deployments...















EX:








kubectl delete deployment <deployment-name>










EX:







kubectl create deployment my-first-deployment --image=nothingnothings/kub-first-app









--> COLOCAMOS em '--image' A NOSSA URL DO DOCKERHUB...






















minikube dashboard ---------> ABRE A DASHBOARD do minikube..
















EX:













 TEMOS 

  1 COMANDO 

  AINDA MAIS CONVENIENTE 

  PARA __ EXPOR__ OS PODS _ CRIADOS POR 1 DEPLOYMENT __ AO MUNDO EXTERIOR__ ----->








É O COMMAND DE  'kubectl expose'












--> esse comando faz o que diz o nome,

ele 

EXPÕE 1 POD, CRIADO POR 1 DEPLOYMENT,




POR MEIO DO CREATE DE 1 SERVICE....










kubectl expose deployment <deployment-object-name> --port=xxxx

















ex:









kubectl expose deployment first-app --port=8080


















também precisamos da option de '--type' (--type e --port são options obrigatórias)..








ex:










kubectl expose deployment first-app  --type=ClusterIP --port=8080








('ClusterIP' é o type DEFAULT de coisa que vc vai querer expor)... ----> O 'ClusterIP'



faz com que 


SEU DEPLOYMENT FIQUE 'REACHABLE' APENAS __ NO LADO DE DENTRO DO SEU CLUSTER (E não do lado de fora)..





A UTILIDADE DE 'ClusterIP' é que ele te dá um 'UNCHANGABLE ADDRESS',


que não vai mudar, e que pode ser usado no contexto interno do kubernetes cluster... 











--> OK... ALÉM DE 'ClusterIP',






temos 





'NodePort',



QUE 



ACTUALLY SIGNIFICA 






''''ESSE DEPLOYMENT DEVERÁ SER ___ EXPOSTO COM A AJUDA DO IP ADDRESS 

DO __ WORKER__ NODE __ __ EM QUE ELE ESTÁ SENDO RODANDO''''' 







--> ISSO QUER DIZER QUE O 'NodePort' VAI DEIXAR ESSE __ DEPLOYMENT SER ACESSÍVEL 

DO LADO DE FORA 



DO CLUSTER...








MAS MELHOR DO QUE ISSO,
 

 TEMOS 

 O 

 TYPE DE 'LOAD BALANCER' ('LoadBalancer') --> ESSE TYPE USA UM 'LOAD BALANCER',




QUE __ DEVERÁ EXISTIR (Vc precisa settar) NA SUA INFRAESTRUTURA,

NA INFRAESTRUTURA  EM QUE VC RODARÁ SEU CLUSTEr (aws, por exemplo)...








ex:







SE ESCOLHEMOS 'LoadBalancer' como type,  é esse load balancer que vai gerar 

1 

'unique address' para esse service... mas mais do que isso,

ele vai 

também 

'DISTRIBUTE INCOMING TRAFFIC EVENLY ACROSS ALL PODS WHICH ARE PART OF THIS 
SERVICE'...















--> COMO TEMOS APENAS 1 POD,

NÃO TEMOS MÚLTIPLAS INSTANCES DESSE POD,




TER  O TYPE DE 'LOADBALANCER' AQUI NÃO FAZ TANTA DIFERENÇA... MAS EM PRODUCTION,


COM MÚLTIPLAS INSTANCES DESSE POD,




ISSO IMPORTARIA....








EX:











--> CERTO.... MAS O LOAD BALANCER,



ESSE TYPE DE 'LoadBalancer',



SÓ PODE SER USADO  __ SE 


O SEU CLUSTER E A INFRAESTRUTURA EM QUE O CLUSTER RODA 


SUPORTAM ESSA TECNOLOGIA...















EX:









kubectl expose deployment <deployment-name> --type/LoadBalancer --port=8080













--> ISSO TUDO COM O APPROACH IMPERATIVE, É CLARO...


















kubectl get services --> mostra os SERVICES ATUALMENTE CRIADOS/SETTADOS...











VEREMOS ISTO:












C:\WINDOWS\system32>kubectl get deployments
NAME                  READY   UP-TO-DATE   AVAILABLE   AGE
my-first-deployment   1/1     1            1           5h4m

C:\WINDOWS\system32>kubectl expose deployment --type=LoadBalancer --port=8080
error: resource(s) were provided, but no name was specified

C:\WINDOWS\system32>kubectl expose deployment my-first-deployment --type=LoadBalancer --port=8080
service/my-first-deployment exposed

C:\WINDOWS\system32>kubectl get services
NAME                  TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
kubernetes            ClusterIP      10.96.0.1       <none>        443/TCP          5h48m
my-first-deployment   LoadBalancer   10.101.118.96   <pending>     8080:30107/TCP   9s

C:\WINDOWS\system32>











EX:










O de baixo,



'kubernetes',





TEM O TYPE DE 'CLUSTERIP',



E É 


1 SERVICE QUE É CRIADO AUTOMATICAMENTE, PELO PRÓPRIO KUBERNETES...










EX:












-> CERTO...








MAS EM 'my-first-deployment' 





ENXERGAMOOS O SERVICE PARA O _ PRIMEIRO DEPLOYMENT... --> TEMOS O TYPE DE 

'LOADBALANCER',



e 



o 'CLUSTERIP',

que não nos ajudará...
















EX:











--> CERTO...





TEMOS TAMBÉM O 'EXTERNAL IP' ---------> SE ISSO FOSSE DEPLOYADO EM 1 'CLOUD PROVIDER',


VERÍAMOS 1 VALOR ALI NO 'EXTERNAL-IP'... MAS COMO 


ESTAMOS NO MINIKUBE,


ESSE NEGÓCIO SEMPRE FICARÁ COMO 'PENDING'...













minikube service --> esse comando existe  SÓ NO MINIKUBE... serve para MAPPEARMOS 

nosso service do deployment a alguma PORT no nosso computador local/local machine ....







('minikube service' NÃO EXISTE EM CLOUD PROVIDERS, pq lá vc já vai ter 1 'external ip' 

válido, a essa altura)












EX:












-> ok... rodamos 'minikube service my-first-deployment'...



--> ESSE COMANDO VAI NOS DAR 1 TABLE COM 1 ADDRESS, QUE ENTÃO PODEREMOS USAR PARA 'VIEW'

A NOSSA APPLICATION...





EX:






C:\WINDOWS\system32>kubectl get services
NAME                  TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
kubernetes            ClusterIP      10.96.0.1       <none>        443/TCP          5h48m
my-first-deployment   LoadBalancer   10.101.118.96   <pending>     8080:30107/TCP   9s

C:\WINDOWS\system32>minikube service my-first-deployment
|-----------|---------------------|-------------|----------------------------|
| NAMESPACE |        NAME         | TARGET PORT |            URL             |
|-----------|---------------------|-------------|----------------------------|
| default   | my-first-deployment |        8080 | http://172.22.142.92:30107 |
|-----------|---------------------|-------------|----------------------------|
* Opening service default/my-first-deployment in default browser...












EX:















DIGAMOS QUE __ NÃO TEMOS AUTO-SCALING ATIVADO... --> ISSO QUER DIZER QUE 


O 



KUBERNETES NÃO VAI CRIAR MAIS OU MENOS PODS... 










-> MAS DIGAMOS QUE _ TEMOS CERTEZA DE QUE 

'TEREMOS MAIS TRAFFIC INCOMING' --> POR ISSO DIGAMOS QUE 

QUEREMOS 

QUE 






NOSSO POD, E O CONTAINER DENTRO DESSE POD,




RODANDO MAIS DO QUE 1 VEZ,

E SIM 





3 VEZES... -------> PODEMOS OBTER ESSE RESULTADO COM O COMANDO 


'kubectl scale ....'







PARA ISSO,

ESCREVEREMOS:









kubectl scale deployment/my-first-deployment 














É ASSIM QUE IDENTIFICAMOS 


OS NOSSOS DEPLOYMENTS (com 'deployment/nome-do-deployment')...











OK... ISSO FEITO,

ADICIONAMOS 






A FLAG DE '--replicas'



PARA SIMPLESMENTE 


ESPECIFICAR  






__ QUANTAS__ INSTANCES,


QUANTOS PODS,


QUEREMOS TER...

















--> por exemplo, podemos querer settar o número de pods como '3'...






ex:







kubectl scale deployment/my-first-deployment --replicas=3











EX:








--> OK.... AGORA TEMOS NOSSOS 2 PODS EXTRAS RODANDO...














-> CERTO... E ELES ESTÃO RODANDO O MESMO CONTAINER DO PRIMEIRO POD...












E, COMO ESTAMOS RODANDO 1 'LOAD BALANCER', 





O TRAFFIC DE NOSSO APP _ TAMBÉM SERÁ DISTRIBUÍDO 'EVENLY' 






AO __ LONGO DESSES DIFERENTES PODS E OS CONTAINERS RODANDO NELES...


















-> CERTO... E ELES ESTÃO RODANDO O MESMO CONTAINER DO PRIMEIRO POD...





--> podemos testar isso 



com a route de '/error'...













--> PODEMOS ENTRAR NA PAGE DE '/error' 1 vez,




e aí 




SAIR DESSA  PAGE...









-> SE FIZERMOS ISSO E CHECARMOS A DASHBOARD DO MINIKUBE,

VEREMOS QUE 





__ APENAS 1 DAS INSTANCES/PODS ESTARÁ 'DOWN',

AO PASSO QUE 


OUTROS 2 PODS AINDA ESTARÃO RODANDO....









-_> COMO OS 2 OUTROS PODS AINDA ESTÃO RODANDO ,


AINDA SOMOS CAPAZES DE VISITAR A NOSSA PAGE,

COMO SE NADA TIVESSE ACONTECIDO (impressionante)...















--> o pod que foi 'TERMINATED' eventualmente vai restartar,



MAS O QUE INTERESSA É QUE O INCOMING TRAFFIC VAI SER REDIRECIONADO 


A OUTRO POD...











--> ISSO QUER DIZER QUE O TRAFFIC 

NÃO VAI SER DIRECIONADO A 1 MESMO POD O TEMPO INTEIRO,



PQ 

ELE _ VAI __ SER DISTRIBUÍDO AO LONGO DE NOSSOS DIFERENTES PODS...











--> ISSO QUER DIZER QUE O SCALING,

MESMO QUANDO NÃO ACONTECE AUTOMATICAMENTE,


É OUTRA FEATURE MT ÚTIL QUE GANHAMOS, COM O KUBERNETES...










EX:









PODEMOS 


RODAR 


'kubectl set',


PARA _ UPDATAr_ _ NOSSO 





DEPLOYMENT...








EX:










kubectl set ----------> PODEMOS COLOCAR 



'kubectl set image',









PARA __ SETTAR 1 NOVA IMAGE PARA __ 1 DEPLOYMENT ESPECÍFICO...












-> BASTA ESCREVER 




kubectl set image/nome-do-seu-deployment...






EX:



kubectl set image deployment/my-first-deployment












--> MAS É CLARO QUE AGORA PRECISAMOS 


COMUNICAR AO KUBERNETES ''''QUAL SERÁ ESSA NOVA IMAGE'''....














PARA ISSO, TEMOS QUE ESPECIFICAR BEM:



kubectl set image deployment/my-first-deployment kub-first-app=nothingnothings/kub-first-app:2













PARA VERIFICAR SE SEU UPDATE FOI APLICADO,





O 'CURRENT UPDATING STATUS',


VC DEVE EXECUTAR 

'kubectl rollout status deployment/my-first-deployment'







--> se seu update deu certo, você verá 'sucessfully rolled out!'









MINIKUBE RESTART (em caso de problemas):









minikube delete 




minikube start --container-runtime=containerd
