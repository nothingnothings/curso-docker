






ACABAMOS ESTE MÓDULO...












OLHAMOS TODOS OS CENÁRIOS IMPORTANTES,
QUANDO O ASSUNTO 

É 
O INTERACT 

DE PODS ENTRE SI,



E O INTERACT DOS PODS COM O MUNDO EXTERNO..




















--> VIMOS:




1) POD-INTERNAL COMMUNICATION, através do 'localhost' ---> ISSO SE 2 CONTAINERS ESTIVEREM RODANDO EM 1 MESMO POD, E SE 1 CONTAINER QUISER ENVIAR REQUESTS A OUTRO CONTAINER NESSE POD...









2) 'OUTSIDE WORLD COMMUNICATION' COM NOSSOS PODS, POR MEIO DO CREATE DO TYPE DE 'LoadBalancer'... (QUE TAMBÉM NOS DÁ UM IP FIXO/stable)...










3) DEMOS OUTRA OLHADA EM SERVICES,

MAS VIMOS 

TAMBÉM 


'CLUSTER-INTERNAL COMMUNICATION' --> COM ISSO, ESTUDAMOS QUE É POSSÍVEL
TER 


MÚLTIPLOS PODS FALANDO 1 COM O OUTRO,

E QUE 

AO MESMO TEMPO  PODEMOS DEIXAR ALGUM POD _ ONLY REACHABLE DE DENTRO DO CLUSTER...


(vimos que podemos fazer isso por meio do create 

de 

1
 
 service de type 'ClusterIP', que também tem 1 pouco de load balancing,
 
 MAS QUE 

 NÃO DEIXA SEU IP 

 ADDRESS ABERTO AO MUNDO EXTERNO...
 )











 4) VIMOS QUE PODEMOS VER OS IP ADDRESS MANUALMENTE ( O QUE É RUIM)








 5) OU, QUE USAMOS AQUELE 'AUTO-GENERATED, CLUSTER-INTERNAL DOMAIN NAME' ( como 'auth-service.default')



 VISTO NESTE TRECHO:




       containers:
        - name: users-api
          env: # ? ///esse env COEXISTE com o 'env' lá da dockerfile... vc pode ter os 2, sim, e aí TER CONTAINERS FUNCIONANDO TANTO EM DEV (docker) COMO EM PROD (kub) usando o mesmo 'process.env.AUTH_ADDRESS', a mesma variável no seu código node...
            - name: AUTH_ADDRESS
              # value: localhost:80   ### NO MUNDO KUBERNETES, QUANDO NOS COMUNICAMOS 'DE CONTAINER PARA CONTAINER', internamente em 1 pod ('POD-INTERNAL' COMMUNICATION), DEVEMOS OBRIGATORIAMENTE USAR 'localhost' + 'PORT QUE ESTÁ SENDO USADA PELO CONTAINER QUE VC QUER REACH'...
              #   ### no caso, como o container de 'users-api' quer alcançar o container de 'auth-api', QUE _ ABRIU A PORT DE '80' no contexto interno do pod (sem acesso ao mundo externo), devemos ESCREVER 'localhost:80'... (colocar esse value na nossa environment variable, que será passada nas partes de 'process.env.AUTH_ADDRESS' do código node, dentro do container)....
              # value: 10.105.227.13 ### obtido com 'kubectl get services' no terminal --- mas não devemos usar assim...
              value: auth-service.default # ? ESSA É A MELHOR MANEIRA (coredns) DE ESTABELECER 'POD-TO-POD' COMMUNICATION (basta vc especificar o SERVICE EM QUE SEU OUTRO POD ESTARÁ CONECTADO/ESTÁ CONECTADO)... como queremos nos conectar ao pod de 'auth', basta especificar 'auth-service'...
              ### ? '.namespace' --> precisamos adicionar '.' + 'nome-do-namespace-em-que-isso-está', para que esse COREDNS fucnione...




(é o MELHOR APPROACH)












6) OU, ENTÃO,


QUE UTILIZEMOS O AUTO-GENERATED 




 ENVIRONMENT VARIABLES,

 QUE O KUBERNETES NOS DÁ (


    como 'process.env.AUTH_SERVICE_SERVICE_HOST'... 
 )









7) VIMOS O REVERSE PROXY,



SETTADO LÁ NO 'nginx.conf',


E VISTO LÁ NO CÓDIGO DE NOSSO APP FRONTEND REACT...




 --> E ISSO NOS DEIXA 

 ENABLAR EXATAMENTE 



 O SETUP E 

 COMMUNICATION QUE PRECISAMOSS 


 NO NOSSO DEPLOYED APP..












 --> PODEMOS 'LOCK DOWN'

 O QUE QUEREMOS LOCK DOWN,


 E AÍ 

 PODEMOS 

 ASSEGURAR QUE 
 A API 


 NÃO 


 FICA ACESSÍVEL DO LADO DE FORA (algumas das api/pods),



 e ainda assim 


 póssamos implementar toda a communication necessária com o mundo externo,



 com 

 as tools 

 mostradas neste módulo...